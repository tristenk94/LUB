// Copyright (C) LEGO System A/S - All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited

using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Linq;
using UnityEditor.SceneManagement;
using UnityEditor.Experimental.SceneManagement;

namespace LEGOModelImporter
{
    public class ModelGroupUtility
    {
        public enum UndoBehavior
        {
            withoutUndo,
            withUndo
        }

        /// <summary>
        /// Create a new (auto generated) model with default values
        /// </summary>
        /// <param name="name">The name of the new model</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        /// <returns>The new model</returns>
        public static Model CreateNewDefaultModel(string name, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var modelGO = new GameObject(name);
            Model model = modelGO.AddComponent<Model>();
            model.autoGenerated = true;
            model.pivot = Model.Pivot.BottomCenter;

            // Add LEGOModelAsset component.
            modelGO.AddComponent<LEGOModelAsset>();

            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.RegisterCreatedObjectUndo(model.gameObject, "Creating model for brick without model");
            }
            return model;
        }

        /// /// <summary>
        /// Create a new (auto generated) model group with default values
        /// </summary>
        /// <param name="name">The name of the new group</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        /// <returns>The new model</returns>
        public static ModelGroup CreateNewDefaultModelGroup(string name, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var groupGO = new GameObject(name);
            ModelGroup group = groupGO.AddComponent<ModelGroup>();
            group.groupName = group.name;
            group.autoGenerated = true;

            // Add LEGOModelGroupAsset component.
            groupGO.AddComponent<LEGOModelGroupAsset>();

            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.RegisterCreatedObjectUndo(group.gameObject, "Creating new model group");
            }
            return group;
        }

        /// <summary>
        /// Recompute the pivot of a transform containing bricks.
        /// </summary>
        /// <param name="parent">The transform to recompute the pivot for</param>
        /// <param name="pivotType">The pivot type</param>
        /// <param name="alignRotation">Whether we also want to align rotation relative to bricks</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        /// <returns>Boolean indicating if pivot was recomputed</returns>
        public static bool RecomputePivot(Transform parent, Model.Pivot pivotType = Model.Pivot.BottomCenter, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            if(pivotType == Model.Pivot.Original)
            {
                return false;
            }
            
            var bricks = parent.GetComponentsInChildren<Brick>();
            
            Brick referenceBrick = null;
            var closestAngleToUp = 100000.0f;
            foreach (var brick in bricks)
            {
                var newAngle = Vector3.Angle(brick.transform.up, parent.up);
                if (newAngle < closestAngleToUp)
                {
                    closestAngleToUp = newAngle;
                    referenceBrick = brick;
                }
            }

            if (!referenceBrick)
            {
                return false;
            }

            var oldRotations = new List<Quaternion>();
            var oldPositions = new List<Vector3>();

            Vector3 pivot;

            if(pivotType == Model.Pivot.BottomCenter)
            {
                var closestAxis = MathUtils.FindClosestAxis(referenceBrick.transform, parent.up, out var axis);
                var (newRight, newForward) = MathUtils.GetRelatedAxes(referenceBrick.transform, axis);

                Matrix4x4 m = Matrix4x4.identity;
                m.SetColumn(0, newRight);
                m.SetColumn(1, closestAxis);
                m.SetColumn(2, newForward);

                var bounds = BrickBuildingUtility.ComputeBounds(bricks, m.inverse);
                pivot = bounds.center;

                pivot -= Vector3.up * bounds.extents.y;
                pivot = m.MultiplyPoint(pivot);
            }
            else
            {
                var bounds = BrickBuildingUtility.ComputeBounds(bricks);
                pivot = bounds.center;
            }

            if (Vector3.Distance(parent.position, pivot) < 0.1f)
            {
                return false;
            }

            if(undoBehavior == UndoBehavior.withUndo)
            {
                var collectedTransforms = new List<Transform>();
                collectedTransforms.Add(parent);
                foreach(Transform child in parent)
                {
                    collectedTransforms.Add(child);
                }
                // FIXME: Reconsider Undo.RecordObject to optimize undo registering.
                Undo.RegisterCompleteObjectUndo(collectedTransforms.ToArray(), "Recording groups before moving model group");
            }

            var difference = parent.position - pivot;
            parent.position = pivot;
            foreach (Transform child in parent)
            {
                child.position += difference;
                if(alignRotation)
                {
                    oldRotations.Add(child.transform.rotation);
                    oldPositions.Add(child.transform.position);
                }
            }

            if (alignRotation)
            {
                var up = referenceBrick.transform.up;
                var right = referenceBrick.transform.right;
                var forward = referenceBrick.transform.forward;

                var closest = MathUtils.FindClosestAxis(parent, up, out MathUtils.VectorDirection direction);
                var rot = Quaternion.FromToRotation(closest, up);

                var oldRot = parent.rotation;
                parent.rotation = rot * parent.rotation;

                var m = Matrix4x4.TRS(parent.position, Quaternion.identity, Vector3.one);
                m.SetColumn(0, forward);
                switch(direction)
                {
                    case MathUtils.VectorDirection.Up:
                    m.SetColumn(1, parent.up);
                    break;
                    case MathUtils.VectorDirection.Right:
                    m.SetColumn(1, parent.right);
                    break;
                    case MathUtils.VectorDirection.Forward:
                    m.SetColumn(1, parent.forward);
                    break;
                    case MathUtils.VectorDirection.Down:
                    m.SetColumn(1, -parent.up);
                    break;
                    case MathUtils.VectorDirection.Left:
                    m.SetColumn(1, -parent.right);
                    break;
                    case MathUtils.VectorDirection.Back:
                    m.SetColumn(1, -parent.forward);
                    break;
                }
                m.SetColumn(2, right);

                var related = MathUtils.GetRelatedAxes(parent, direction);
                rot = MathUtils.AlignRotation(m, related.Item1, related.Item2) * rot;
                rot.ToAngleAxis(out float angle, out Vector3 axis);
                parent.rotation = oldRot;
                parent.RotateAround(parent.position, axis, angle);

                var i = 0;
                foreach(Transform child in parent)
                {
                    child.transform.rotation = oldRotations[i];
                    child.transform.position = oldPositions[i++];
                }
            }

            return true;
        }

        /// <summary>
        /// Recompute pivot for a model according to the pivot type set on the model
        /// </summary>
        /// <param name="model">The model to recompute pivot for</param>
        /// <param name="alignRotation">Whether or not to align the rotation according to the bricks in the model</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        public static bool RecomputePivot(Model model, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            return RecomputePivot(model.transform, model.pivot, alignRotation, undoBehavior);
        }

        /// <summary>
        /// Recompute pivot for a model group according to the pivot type set on the model
        /// </summary>
        /// <param name="model">The model group to recompute pivot for</param>
        /// <param name="alignRotation">Whether or not to align the rotation according to the bricks in the model group</param>
        /// <param name="undoBehavior">Whether or not to register undo for this action</param>
        public static bool RecomputePivot(ModelGroup group, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            return RecomputePivot(group.transform, Model.Pivot.BottomCenter, alignRotation, undoBehavior);
        }

        private static void SetParent(Transform transform, Transform parent, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {            
            if(transform.parent == parent)
            {
                return;
            }

            if (IsPartOfPrefab(transform.gameObject))
            {
                UnpackPrefab(transform.gameObject, undoBehavior);
            }

            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.SetTransformParent(transform, parent, "Setting transform parent");
            }
            else
            {
                transform.SetParent(parent, true);
            }
        }

        private static void DestroyObject(GameObject go, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            if (undoBehavior == UndoBehavior.withUndo)
            {
                Undo.DestroyObjectImmediate(go);
            }
            else
            {
                Object.DestroyImmediate(go);
            }
        }

        private static bool IsPartOfPrefab(Brick brick)
        {
            return brick.transform.parent && PrefabUtility.IsPartOfAnyPrefab(brick.transform.parent) && !PrefabUtility.IsAddedGameObjectOverride(brick.gameObject);                
        }

        private static bool IsPartOfPrefab(GameObject go)
        {
            return go.transform.parent && PrefabUtility.IsPartOfAnyPrefab(go.transform.parent) && !PrefabUtility.IsAddedGameObjectOverride(go);
        }

        private static void UnpackPrefab(Brick brick, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var root = PrefabUtility.GetOutermostPrefabInstanceRoot(brick);
            PrefabUtility.UnpackPrefabInstance(root.gameObject, PrefabUnpackMode.Completely, undoBehavior == UndoBehavior.withUndo ? InteractionMode.UserAction : InteractionMode.AutomatedAction);
        }

        private static void UnpackPrefab(GameObject gameObject, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            var root = PrefabUtility.GetOutermostPrefabInstanceRoot(gameObject);
            PrefabUtility.UnpackPrefabInstance(root.gameObject, PrefabUnpackMode.Completely, undoBehavior == UndoBehavior.withUndo ? InteractionMode.UserAction : InteractionMode.AutomatedAction);
        }

        private static ModelGroup GetGroupInParent(GameObject go)
        {
            return go.GetComponentInParent<ModelGroup>(true);
        }

        private static Model GetModelInParent(GameObject go)
        {
            return go.GetComponentInParent<Model>(true);
        }

        /// <summary>
        /// Recompute the model and model group hierarchy.
        /// Some rules:
        /// 1. A brick will always be in a model group, which will always be in a model.
        /// 2. Empty models and model groups are destroyed.
        /// 3. Bricks can not contain bricks, model groups can not contain model groups and models can not contain models. So they are flattened.
        /// </summary>
        /// <param name="bricks">The bricks that we need to check the hierarchy for</param>
        /// <param name="alignRotation">Whether or not we also align rotation when we recompute pivot</param>
        /// <param name="undoBehavior">Whether or not to register undo for the recomputation of hierarchy</param>
        public static void RecomputeHierarchy(IEnumerable<Brick> bricks, bool alignRotation = true, UndoBehavior undoBehavior = UndoBehavior.withUndo)
        {
            // Group numbers are numbers in parentheses
            // So group 1 with three bricks is shown as (1, 1, 1) 
            // In case the group is part of a prefab it is suffixed with a p like (1p, 1p)
            // In case one of the bricks in a group is an override it is noted with a + as in (1p, 1p+)

            // Cases for splitting:
            // (1, 1) -> (1) (1)
            // (1, 1) (2) -> (1) (1, 2) -> (1) (2, 2)

            // Cases for unpacking:
            // (1p) (2p) -> (1, 2p) -> (2p+, 2p)
            // (1p, 1p+) (2p) -> (1, 1, 2p) -> (2p+, 2p+, 2p)
            // (1p, 1p) -> (1p) (1p) -> (1) (1)

            // Only set parent:
            // (1) (2) -> (1, 2) -> (2, 2)
            // (1p, 1p+) (2p) -> (1p) (1p+, 2p) -> (1p) (2p+, 2p)
            // (1p, 1p+) (2) -> (1p) (1p+, 2) -> (1p) (2, 2)

            if(PrefabStageUtility.GetCurrentPrefabStage() != null)
            {
                var rootObject = PrefabStageUtility.GetCurrentPrefabStage().prefabContentsRoot;
                var brick = rootObject.GetComponent<Brick>();
                if(brick)
                {
                    return;
                }
            }

            // First we flatten models
            var modelsToCheck = new HashSet<Model>();
            var groupsToCheck = new HashSet<ModelGroup>();
            var bricksToCheck = new HashSet<Brick>();

            foreach(var brick in bricks)
            {
                var bricksInParent = brick.GetComponentsInParent<Brick>(true);
                if(bricksInParent.Length > 1)
                {
                    bricksToCheck.Add(brick);
                }
                var modelsInParent = brick.GetComponentsInParent<Model>(true);
                if(modelsInParent.Length > 1)
                {
                    modelsToCheck.UnionWith(modelsInParent);
                }
                var groupsInParent = brick.GetComponentsInParent<ModelGroup>(true);
                if(groupsInParent.Length > 1)
                {
                    groupsToCheck.UnionWith(groupsInParent);
                }
            }

            foreach(var model in modelsToCheck)
            {
                var modelsInModel = model.GetComponentsInChildren<Model>(true);
                foreach(var inModel in modelsInModel)
                {
                    if (inModel == model)
                    {
                        continue;
                    }

                    var groupsInModel = inModel.GetComponentsInChildren<ModelGroup>();
                    foreach (var group in groupsInModel)
                    {
                        SetParent(group.transform, model.transform, undoBehavior);
                    }
                }
            }

            // Now flatten groups
            foreach(var group in groupsToCheck)
            {
                var groupsInGroup = group.GetComponentsInChildren<ModelGroup>(true);
                foreach(var inGroup in groupsInGroup)
                {
                    if(inGroup == group)
                    {
                        continue;
                    }

                    var bricksInGroup = inGroup.GetComponentsInChildren<Brick>(true);
                    foreach(var brick in bricksInGroup)
                    {
                        SetParent(brick.transform, group.transform, undoBehavior);
                    }
                }
            }

            // Now flatten bricks
            foreach(var brick in bricksToCheck)
            {
                var group = GetGroupInParent(brick.gameObject);
                if(group)
                {
                    SetParent(brick.transform, group.transform, undoBehavior);
                }
            }
            
            var connectedClusters = new List<HashSet<Brick>>();

            // Collect all connected brick lists
            foreach(var brick in bricks)
            {
                if(connectedClusters.Any(x => x.Contains(brick)))
                {
                    continue;
                }

                if(!brick.HasConnectivity())
                {
                    var group = GetGroupInParent(brick.gameObject);
                    var model = GetModelInParent(brick.gameObject);
                    if(!group || !model)
                    {
                        connectedClusters.Add(new HashSet<Brick>{brick});
                    }
                }
                else
                {
                    var connected = brick.GetConnectedBricks();
                    connected.Add(brick);
                    connectedClusters.Add(connected);
                }
            }

            // Now find all groups for each cluster
            var groupsPerCluster = new List<(HashSet<Brick>, HashSet<ModelGroup>, HashSet<Brick>)>();
            foreach(var cluster in connectedClusters)
            {
                if(cluster.Count == 0)
                {
                    continue;
                }

                var bricksNotInGroup = new HashSet<Brick>();
                var groups = new HashSet<ModelGroup>();
                foreach(var brick in cluster)
                {
                    var group = GetGroupInParent(brick.gameObject);                    
                    if(group)
                    {
                        groups.Add(group);
                    }
                    else
                    {
                        bricksNotInGroup.Add(brick);
                    }
                }
                groupsPerCluster.Add((cluster, groups, bricksNotInGroup));
            }

            // Sorting makes sure we merge before we split. Merging will make it easier to see what we need to split later.
            groupsPerCluster = groupsPerCluster.OrderByDescending(x => x.Item2.Count).ToList();

            var modelsToRecompute = new HashSet<Model>();
            var groupsToRecompute = new HashSet<ModelGroup>();

            // Check through each of these groups in the cluster
            foreach (var groupPerCluster in groupsPerCluster)
            {
                var cluster = groupPerCluster.Item1;
                var groups = groupPerCluster.Item2;
                var notInGroup = groupPerCluster.Item3;
                // If the cluster has more than one group, we need to merge them
                if(groups.Count > 1)
                {
                    // Merge some groups
                    ModelGroup largestGroup = null;
                    int largestGroupSize = 0;
                    foreach (var group in groups)
                    {
                        var bricksInGroup = group.GetComponentsInChildren<Brick>(true);
                        var bricksInCluster = bricksInGroup.Count(x => cluster.Contains(x));
                        var fullyContained = true;
                        foreach (var brick in bricksInGroup)
                        {
                            if (!cluster.Contains(brick))
                            {
                                fullyContained = false;
                            }
                        }

                        if(!fullyContained)
                        {
                            continue;
                        }

                        if (bricksInCluster >= largestGroupSize)
                        {
                            largestGroup = group;
                            largestGroupSize = bricksInCluster;
                        }
                    }
                    
                    if(largestGroup)
                    {
                        foreach(var brick in cluster)
                        {
                            if (brick.transform.parent == largestGroup.transform)
                            {
                                continue;
                            }

                            SetParent(brick.transform, largestGroup.transform, undoBehavior);
                        }
                    }
                    groupsToRecompute.Add(largestGroup);
                }
                else if (groups.Count == 1) // In case the cluster only has one group, we need to check if the group contains bricks not in this cluster
                {
                    var group = groups.FirstOrDefault();
                    if (!group)
                    {
                        continue;
                    }

                    var bricksInGroup = group.GetComponentsInChildren<Brick>(true);
                    var clustersForGroup = new HashSet<HashSet<Brick>>();

                    // If this group contains more than one cluster, split
                    foreach (var brick in bricksInGroup)
                    {
                        if (!clustersForGroup.Any(x => x.Contains(brick)))
                        {
                            if (brick.HasConnectivity())
                            {
                                var connected = brick.GetConnectedBricks();
                                connected.Add(brick);
                                clustersForGroup.Add(connected);
                            }
                        }
                    }

                    // Only split if we found multiple clusters in group
                    if (clustersForGroup.Count > 1)
                    {
                        // Get the model for the group
                        var model = GetModelInParent(group.gameObject);

                        // Find all prefabs we need to unpack by looking through the clusters in the group
                        foreach (var clusterInGroup in clustersForGroup)
                        {
                            // Look through each brick in the cluster
                            foreach (var brick in clusterInGroup)
                            {
                                // First check if there is a brick in this cluster that is part of a prefab and not an override
                                // If there is, then check if there is another cluster containing a prefab that is not an override
                                // In that case, we have to unpack, because we are changing the parents of gameobjects in a prefab
                                if (IsPartOfPrefab(brick))
                                {
                                    if (clustersForGroup.Any(clust => clust != clusterInGroup && clust.Any(obj => !PrefabUtility.IsAddedGameObjectOverride(obj.gameObject))))
                                    {
                                        UnpackPrefab(brick, undoBehavior);
                                        break;
                                    }
                                }
                            }
                        }

                        // Optimization: Check for largest group containing only a single cluster and keep that group intact
                        HashSet<Brick> largestGroupBricks = null;
                        ModelGroup largestGroup = null;
                        int largestGroupSize = 0;
                        var sharedParentClusters = new HashSet<ModelGroup>();

                        foreach (var clusterInGroup in clustersForGroup)
                        {
                            var parent = clusterInGroup.First().transform.parent;
                            var modelGroup = parent.GetComponent<ModelGroup>();
                            if (!modelGroup)
                            {
                                continue;
                            }

                            var skip = false;
                            foreach (var brick in clusterInGroup)
                            {
                                if (brick.transform.parent != parent)
                                {
                                    skip = true;
                                    break;
                                }
                            }
                            if (skip)
                            {
                                continue;
                            }

                            if (largestGroupSize < clusterInGroup.Count())
                            {
                                largestGroupSize = clusterInGroup.Count();
                                largestGroupBricks = clusterInGroup;
                                largestGroup = modelGroup;
                            }
                        }

                        if (largestGroupBricks != null)
                        {
                            clustersForGroup.Remove(largestGroupBricks);
                        }

                        foreach (var clusterInGroup in clustersForGroup)
                        {
                            var newObject = new GameObject();
                            var newGroup = newObject.AddComponent<ModelGroup>();

                            // Add LEGOModelGroupAsset component.
                            newObject.AddComponent<LEGOModelGroupAsset>();

                            if (undoBehavior == UndoBehavior.withUndo)
                            {
                                Undo.RegisterCreatedObjectUndo(newObject, "Created new group");
                            }

                            newGroup.transform.position = group.transform.position;

                            if (model)
                            {
                                SetParent(newGroup.transform, model.transform, undoBehavior);
                            }

                            newGroup.name = group.groupName;
                            newGroup.groupName = group.groupName;
                            newGroup.parentName = group.parentName;
                            newGroup.optimizations = group.optimizations;
                            newGroup.randomizeNormals = group.randomizeNormals;
                            foreach (var view in group.views)
                            {
                                newGroup.views.Add(new CullingCameraConfig()
                                {
                                    name = view.name,
                                    perspective = view.perspective,
                                    position = view.position,
                                    rotation = view.rotation,
                                    fov = view.fov,
                                    size = view.size,
                                    minRange = view.minRange,
                                    maxRange = view.maxRange,
                                    aspect = view.aspect
                                });
                            }
                            newGroup.autoGenerated = true;

                            foreach (var brick in clusterInGroup)
                            {
                                SetParent(brick.transform, newGroup.transform, undoBehavior);
                            }
                            
                            groupsToRecompute.Add(newGroup);
                        }
                    }
                    else if (notInGroup.Count > 0)
                    {
                        foreach (var brick in notInGroup)
                        {
                            if (IsPartOfPrefab(brick))
                            {
                                UnpackPrefab(brick, undoBehavior);
                            }
                            SetParent(brick.transform, group.transform, undoBehavior);
                        }
                    }
                    else
                    {
                        groupsToRecompute.Add(group);

                        var modelGO = group.transform.parent;
                        bool createNewModel = (PrefabStageUtility.GetCurrentPrefabStage() != null && modelGO && !modelGO.GetComponent<Model>())
                                            || (PrefabStageUtility.GetCurrentPrefabStage() == null && (!modelGO || !modelGO.GetComponent<Model>()));

                        if(createNewModel)
                        {
                            Model model = CreateNewDefaultModel(group.name, undoBehavior);
                            if(modelGO != null)
                            {
                                if (PrefabStageUtility.GetCurrentPrefabStage() == null && PrefabUtility.IsPartOfAnyPrefab(modelGO))
                                {
                                    UnpackPrefab(modelGO.gameObject, undoBehavior);
                                }
                            }
                            SetParent(group.transform, model.transform, undoBehavior);
                            EditorGUIUtility.PingObject(group.gameObject);
                        }
                    }
                }
                else // No groups.
                {
                    var first = cluster.FirstOrDefault();
                    string name = "";
                    if (first)
                    {
                        name = first.name;
                    }
                    Model model = null;

                    if (PrefabStageUtility.GetCurrentPrefabStage() != null)
                    {
                        var rootObject = PrefabStageUtility.GetCurrentPrefabStage().prefabContentsRoot;
                        model = rootObject.GetComponent<Model>();
                        if (!model)
                        {
                            model = CreateNewDefaultModel(name);
                            SetParent(model.transform, rootObject.transform, undoBehavior);
                        }
                    }
                    else
                    {
                        model = CreateNewDefaultModel(name);
                    }

                    ModelGroup newGroup = CreateNewDefaultModelGroup(name);

                    SetParent(newGroup.transform, model.transform, undoBehavior);
                    var bounds = BrickBuildingUtility.ComputeBounds(cluster, Matrix4x4.identity);
                    model.transform.position = new Vector3(bounds.center.x, bounds.min.y, bounds.center.z);

                    Transform originalParent = null;
                    foreach (var brick in cluster)
                    {
                        if (!originalParent)
                        {
                            originalParent = brick.transform.parent;
                        }
                        if (brick.transform.parent != originalParent)
                        {
                            originalParent = null;
                            break;
                        }
                    }

                    if (originalParent)
                    {
                        SetParent(model.transform, originalParent, undoBehavior);
                    }

                    foreach (var brick in cluster)
                    {
                        SetParent(brick.transform, newGroup.transform, undoBehavior);
                        EditorGUIUtility.PingObject(brick.gameObject);
                    }
                }
            }

            var groupsInScene = StageUtility.GetCurrentStageHandle().FindComponentsOfType<ModelGroup>();
            foreach(var group in groupsInScene)
            {
                if (!group.processed)
                {
                    var children = group.GetComponentsInChildren<Brick>(true);
                    if (children.Length == 0)
                    {
                        DestroyObject(group.gameObject);
                    }
                }
            }

            var modelsInScene = StageUtility.GetCurrentStageHandle().FindComponentsOfType<Model>();
            foreach (var model in modelsInScene)
            {
                var children = model.GetComponentsInChildren<ModelGroup>(true);
                if (children.Length == 0)
                {
                    DestroyObject(model.gameObject);
                }
            }

            foreach (var group in groupsToRecompute)
            {
                if (group)
                {
                    if(RecomputePivot(group, alignRotation, undoBehavior))
                    {
                        modelsToRecompute.Add(group.transform.parent.GetComponent<Model>());
                    }
                }
            }

            foreach (var model in modelsToRecompute)
            {
                if (model)
                {
                    RecomputePivot(model, alignRotation, undoBehavior);
                }
            }
        }
    }
}
